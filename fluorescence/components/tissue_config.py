"""
    --- AUTO-GENERATED DOCSTRING ---
    Table of content is automatically generated by Agent Docstrings v1.3.5

    Classes/Functions:
        - create_coefficient_plot(wavelengths: np.ndarray, y_values: np.ndarray, title: str, line_color: str, marker_color: str) -> go.Figure (line 52)
        - add_formula_spacing() (line 96)
        - create_parameter_relationship_plot(param_values: np.ndarray, coefficients: np.ndarray, param_name: str, current_value: float, line_color: str) -> go.Figure (line 102)
        - render_scattering_section(col, params) -> tuple[float, float, float] (line 152)
        - render_absorption_section(col, params) -> float (line 302)
        - render_math_view() (line 384)
    --- END AUTO-GENERATED DOCSTRING ---

Configuration for tissue penetration modeling.
"""
import numpy as np
import plotly.graph_objects as go
import streamlit as st


# Changed from relative to absolute import
from fluorescence.utils.data_loader import load_water_absorption_data
from fluorescence.config import TISSUE_PLOT_CONFIG, TISSUE_PARAMETER_CONFIGS, DEFAULT_TISSUE_PARAMS

# Formula display configuration
MAIN_FORMULA_SIZE = r"\Large"  # Size for the main formula
FORMULA_SIZE = r"\large"      # Size for other formulas
FORMULA_SPACING = 2          # Number of blank lines after formulas

# Parameter colors for consistent styling
A_COLOR = "#2ca02c"  # Green for scattering scale (a)
G_COLOR = "#ff7f0e"  # Orange for anisotropy (g)
W_COLOR = "#9467bd"  # Purple for water content (w)
MU_S_COLOR = "#1f77b4"  # Blue for scattering coefficient
MU_A_COLOR = "#d62728"  # Red for absorption coefficient
Z_COLOR = "#6c63ff"  # Purple for depth (z)
B_COLOR = "#d62728"  # Red for scattering power (b)

# Plot configuration
# PLOT_CONFIG = {
#     "height": 300,
#     "small_height": 250,  # Increased height for parameter plots
#     "margin": dict(l=20, r=20, t=40, b=20),  # Adjusted margins
#     "small_margin": dict(l=20, r=20, t=40, b=20),
#     "hovermode": 'x unified',
#     "wavelength_range": [800, 2400],
#     "reference_wavelength": 1300,
#     "showlegend": False,  # Hide legend by default
#     "aspect_ratio": 1.2,  # For more square-like appearance
# }

# Default tissue parameters to match the paper
# DEFAULT_TISSUE_PARAMS = {
#     "depth": 1.0,  # 1mm depth as shown in image
#     "water_content": 0.75,  # 75% as specified
#     "g": 0.9,  # Matches paper
#     "a": 1.1,  # 1.1 mm^-1 as specified
#     "b": 1.37,  # Matches paper
#     "absorption_threshold": 50,  # Percentage threshold for shading
# }


def create_coefficient_plot(
    wavelengths: np.ndarray,
    y_values: np.ndarray,
    title: str,
    line_color: str,
    marker_color: str,
) -> go.Figure:
    """Create a coefficient plot with consistent styling."""
    fig = go.Figure()

    # Add main line
    fig.add_trace(go.Scatter(
        x=wavelengths,
        y=y_values,
        mode='lines',
        showlegend=False,
        line=dict(color=line_color)
    ))

    # Add reference point
    ref_idx = np.abs(
        wavelengths - TISSUE_PLOT_CONFIG["reference_wavelength"]).argmin()
    fig.add_trace(go.Scatter(
        x=[TISSUE_PLOT_CONFIG["reference_wavelength"]],
        y=[y_values[ref_idx]],
        mode='markers',
        showlegend=False,
        marker=dict(size=10, color=marker_color)
    ))

    # Update layout
    fig.update_layout(
        title=title,
        xaxis_title="Wavelength (nm)",
        yaxis_title=f"{title} (mm⁻¹)",
        height=TISSUE_PLOT_CONFIG["height"],
        margin=TISSUE_PLOT_CONFIG["margin"],
        hovermode=TISSUE_PLOT_CONFIG["hovermode"],
        showlegend=False
    )

    return fig


def add_formula_spacing():
    """Add consistent spacing after formulas."""
    for _ in range(FORMULA_SPACING):
        st.write("")


def create_parameter_relationship_plot(
    param_values: np.ndarray,
    coefficients: np.ndarray,
    param_name: str,
    current_value: float,
    line_color: str,
) -> go.Figure:
    """Create a plot showing direct relationship between parameter and coefficient."""
    fig = go.Figure()

    # Add main line
    fig.add_trace(go.Scatter(
        x=param_values,
        y=coefficients,
        mode='lines',
        showlegend=False,  # Hide legend
        line=dict(color=line_color)
    ))

    # Add point for current value
    fig.add_trace(go.Scatter(
        x=[current_value],
        y=[np.interp(current_value, param_values, coefficients)],
        mode='markers',
        showlegend=False,  # Hide legend
        marker=dict(size=10, color='black')
    ))

    # Update layout for more square-like appearance
    fig.update_layout(
        title=dict(
            text=f"Coefficient vs {param_name}",
            y=0.95,  # Adjust title position
            x=0.5,
            xanchor='center',
            yanchor='top'
        ),
        xaxis_title=param_name,
        yaxis_title="Coefficient (mm⁻¹)",
        height=TISSUE_PLOT_CONFIG["small_height"],
        margin=TISSUE_PLOT_CONFIG["small_margin"],
        hovermode='x unified',
        showlegend=False,
        # Make plot more square-like
        width=TISSUE_PLOT_CONFIG["small_height"] *
        TISSUE_PLOT_CONFIG["aspect_ratio"]
    )

    return fig


def render_parameter_control_with_popover(
    label: str,
    value: float,
    min_value: float,
    max_value: float,
    step: float,
    help_text: str,
    popover_title: str,
    popover_help: str,
    popover_values: np.ndarray,
    popover_coefficients: np.ndarray,
    popover_param_name: str,
    popover_current_value: float,
    popover_line_color: str,
    popover_formula: str,
    popover_markdown: str,
    is_slider: bool = True
) -> float:
    """Render a parameter control (slider or number input) with a popover for impact visualization."""
    if is_slider:
        param = st.slider(
            label,
            min_value,
            max_value,
            value,
            step,
            help=help_text,
        )
    else:
        param = st.number_input(
            label,
            min_value=min_value,
            max_value=max_value,
            value=value,
            step=step,
            help=help_text,
        )
    with st.popover(popover_title, help=popover_help):
        fig = create_parameter_relationship_plot(
            param_values=popover_values,
            coefficients=popover_coefficients,
            param_name=popover_param_name,
            current_value=popover_current_value,
            line_color=popover_line_color
        )
        st.plotly_chart(fig, use_container_width=True)
        st.markdown("**Impact of {}:**".format(popover_param_name))
        st.latex(popover_formula)
        st.markdown(popover_markdown)
    return param


def render_tissue_parameter_controls(params, ref_wavelength=None):
    """No longer renders any controls; all are in dashboard. Returns None."""
    return None


def render_scattering_section(col, params) -> tuple[float, float, float]:
    """
    Render the scattering properties section.

    Args:
        col: Streamlit column object
        params: Dictionary of tissue parameters

    Returns:
        tuple[float, float, float]: Updated (g, b, a) parameters
    """

    # Create two columns for plot and controls
    plot_col, controls_col = col.columns([2, 1])

    with plot_col:
        # Main scattering plot
        wavelengths = np.linspace(
            *TISSUE_PLOT_CONFIG["wavelength_range"], 1000)
        mus_prime = params['a'] * (wavelengths / 500) ** (-params['b'])
        mus = mus_prime / (1 - params['g'])

        fig = create_coefficient_plot(
            wavelengths=wavelengths,
            y_values=mus,
            title="Scattering Coefficient",
            line_color='blue',
            marker_color='red'
        )
        st.plotly_chart(fig, use_container_width=True)

        # Scattering formula below the plot
        st.markdown("#### Scattering Formula")
        scattering_formula = (
            f"{FORMULA_SIZE} \\mu_s(\\lambda) &= \\frac{{a}}{{1-g}} \\cdot "
            r"\left(\frac{\lambda}{500}\right)^{-b} \\" +
            "\n"  # Add line break
            f"&= \\frac{{\\color{{red}}{{{params['a']:.2f}}}}}"
            f"{{1-\\color{{red}}{{{params['g']:.2f}}}}} \\cdot "
            r"\left(\frac{\lambda}{500}\right)^{" +
            f"\\color{{red}}{{-{params['b']:.2f}}}" + "}"
        )
        st.latex("\\begin{align*}" + scattering_formula + "\\end{align*}")

    with controls_col:
        g, b, a = render_tissue_parameter_controls(params)

    return g, b, a


def render_absorption_section(col, params) -> float:
    """
    Render the absorption properties section.

    Args:
        col: Streamlit column object
        params: Dictionary of tissue parameters

    Returns:
        float: Updated water_content parameter
    """

    # Create two columns for plot and controls
    plot_col, controls_col = col.columns([2, 1])

    with plot_col:
        # Main absorption plot
        water_data = load_water_absorption_data()
        wavelengths = np.linspace(
            *TISSUE_PLOT_CONFIG["wavelength_range"], 1000)
        mua = np.interp(
            wavelengths, water_data["wavelength"], water_data["absorption"])
        mua = mua * params['water_content'] / 10

        fig = create_coefficient_plot(
            wavelengths=wavelengths,
            y_values=mua,
            title="Absorption Coefficient",
            line_color='red',
            marker_color='blue'
        )
        st.plotly_chart(fig, use_container_width=True)

        # Absorption formula below the plot
        st.markdown("#### Absorption Formula")
        absorption_formula = (
            f"{FORMULA_SIZE} \\mu_a(\\lambda) &= \\mu_a^{{\\lambda}} \\cdot w \\" + "\n"
            f"                                &= \\mu_a^{{\\lambda}} \\cdot \\color{{#d62728}}{{{params['water_content']:.2f}}}"
        )
        st.latex("\\begin{align*}" + absorption_formula + "\\end{align*}")

        # Water content is now managed in the dashboard; just display the value


# --- POPUP RENDERERS FOR MATHEMATICAL MODEL ---
def render_scattering_popover(a, g, b, ref_wavelength):
    mus_scattering = a * (ref_wavelength / 500) ** (-b) / (1 - g)
    with st.popover("Scattering Coefficient (μₛ)", use_container_width=True):
        st.markdown('<div style="text-align: center;">',
                    unsafe_allow_html=True)
        st.subheader("Scattering Coefficient (μₛ)")
        st.markdown(
            f"Describes how light is scattered in tissue. Depends on wavelength (λ), "
            f"scattering scale $\\color{{{A_COLOR}}}{{a}}$, anisotropy $\\color{{{G_COLOR}}}{{g}}$, and power $\\color{{{B_COLOR}}}{{b}}$.",
            unsafe_allow_html=True
        )
        scattering_formula = rf"""
\mu_s(\lambda) = \frac{{\color{{{A_COLOR}}}{{a}}}}{{1-\color{{{G_COLOR}}}{{g}}}}
\left(\frac{{\lambda}}{{500}}\right)^{{-\color{{{B_COLOR}}}{{b}}}}
\\[1em]
\mu_s({ref_wavelength}) = \color{{{MU_S_COLOR}}}{{{mus_scattering:.3f}}} = \frac{{\color{{{A_COLOR}}}{{{a:.2f}}}}}{{1-\color{{{G_COLOR}}}{{{g:.2f}}}}}
\left(\frac{{{ref_wavelength}}}{{500}}\right)^{{-\color{{{B_COLOR}}}{{{b:.2f}}}}}
"""
        st.latex(scattering_formula)
        st.markdown(
            f'<span style="font-size: 0.8em; color: #888;">*$\\color{{{A_COLOR}}}{{a}}$: scattering scale, $\\color{{{G_COLOR}}}{{g}}$: anisotropy, $\\color{{{B_COLOR}}}{{b}}$: scattering power*</span>',
            unsafe_allow_html=True
        )
        add_formula_spacing()
        st.markdown('</div>', unsafe_allow_html=True)


def render_absorption_popover(water_content, ref_wavelength):
    water_data = load_water_absorption_data()
    mua_lambda = float(
        np.interp(ref_wavelength, water_data["wavelength"], water_data["absorption"]))
    with st.popover("Absorption Coefficient (μₐ)", use_container_width=True):
        st.markdown('<div style="text-align: center;">',
                    unsafe_allow_html=True)
        st.subheader("Absorption Coefficient (μₐ)")
        st.markdown(
            f"Describes how light is absorbed in tissue, primarily by water content $\\color{{{W_COLOR}}}{{w}}$. "
            f"Data is interpolated from water absorption tables.",
            unsafe_allow_html=True
        )
        absorption_formula = rf"""
\mu_a(\lambda) = \mu_a^{{\lambda}} \cdot w
\\[1em]
\mu_a({ref_wavelength}) = \color{{#888}}{{{mua_lambda:.3f}}} \cdot \color{{{W_COLOR}}}{{{water_content:.2f}}}
"""
        st.latex(absorption_formula)
        st.markdown(
            f'<span style="font-size: 0.8em; color: #888;">*$\\color{{{W_COLOR}}}{{w}}$: water content, $\\color{{#888}}{{\\mu_a^\\lambda}}$: water absorption at $\\lambda$*</span>',
            unsafe_allow_html=True
        )
        add_formula_spacing()
        st.markdown('</div>', unsafe_allow_html=True)


def render_transmission_popover(mus_scattering, mua_lambda, water_content, ref_wavelength, depth):
    depth_str = '{:.1f}'.format(depth)
    with st.popover("Transmission (T)", use_container_width=True):
        st.markdown('<div style="text-align: center;">',
                    unsafe_allow_html=True)
        st.subheader("Transmission (T)")
        st.markdown(
            f"Transmission combines scattering and absorption to model light penetration at depth $\\color{{{Z_COLOR}}}{{z}}$. The formula below shows how the total attenuation depends on the scattering and absorption coefficients and the depth.",
            unsafe_allow_html=True
        )
        transmission_formula = rf"""
T(\lambda, z) = e^{{-(\color{{{MU_S_COLOR}}}{{\mu_s}}(\lambda) + \color{{{MU_A_COLOR}}}{{\mu_a}}(\lambda)) \color{{{Z_COLOR}}}{{z}}}}
\\[1em]
T({ref_wavelength}, {depth_str}) = e^{{-({mus_scattering:.3f} + \color{{#888}}{{{mua_lambda:.3f}}} \cdot \color{{{W_COLOR}}}{{{water_content:.2f}}}) \cdot \color{{{Z_COLOR}}}{{{depth_str}}}}}
"""
        st.latex(transmission_formula)
        st.markdown(
            f'<span style="font-size: 0.8em; color: #888;">*$\\color{{{MU_S_COLOR}}}{{\\mu_s}}$: scattering, $\\color{{{MU_A_COLOR}}}{{\\mu_a}}$: absorption, $\\color{{{Z_COLOR}}}{{z}}$: depth, $\\color{{#888}}{{\\mu_a^\\lambda}}$: water absorption at $\\lambda$*</span>',
            unsafe_allow_html=True
        )
        add_formula_spacing()
        st.markdown('</div>', unsafe_allow_html=True)
