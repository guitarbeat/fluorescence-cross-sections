"""
    --- AUTO-GENERATED DOCSTRING ---
    Table of content is automatically generated by Agent Docstrings v1.3.5

    Classes/Functions:
        - fetch_image_content(url: str) (line 23)
        - get_reference_image_url(fluorophore_name: str) -> str (line 33)
        - calculate_fluorophore_stats(df: pd.DataFrame, fluorophore_name: str) -> Dict[str, float] (line 51)
        - format_stats(stats: Dict[str, float]) -> str (line 85)
        - handle_component_error(operation: str, fluorophore_name: str, error: Exception) -> None (line 97)
        - render_fluorophore_viewer(cross_sections: Dict[str, pd.DataFrame], key_prefix: str = '') -> None (line 105)
    --- END AUTO-GENERATED DOCSTRING ---
"""
import logging
from typing import Dict

import pandas as pd
import requests
import streamlit as st

from ..plots.zipfel_cross_sections import plot_cross_section

logger = logging.getLogger(__name__)

@st.cache_data
def fetch_image_content(url: str):
    """Fetch image content from URL with caching and error handling."""
    try:
        response = requests.get(url, timeout=10)
        response.raise_for_status()
        return response.content
    except requests.exceptions.RequestException as e:
        logger.warning(f"Failed to fetch image {url}: {e}")
    return None

def get_reference_image_url(fluorophore_name: str) -> str:
    """
    Get the reference image URL for a given fluorophore.
    Handles common spelling variations.
    """
    base_url = "http://www.drbio.cornell.edu/images/CrossSectionJPGs"

    # Dictionary of filename corrections
    filename_corrections = {
        "Fluoresecein": "Fluorescein",
        # Add more corrections here if needed
    }

    # Use corrected filename if it exists, otherwise use original
    corrected_name = filename_corrections.get(fluorophore_name, fluorophore_name)

    return f"{base_url}/{corrected_name}.jpg"

def _calculate_column_stats(df: pd.DataFrame, columns: list, prefix: str = "") -> Dict[str, float]:
    """Helper function to calculate statistics for multiple columns."""
    stats = {}
    for col in columns:
        peak_idx = df[col].idxmax()
        col_prefix = f"{prefix}{col}_" if prefix else f"{col}_"
        stats[f"{col_prefix}peak_wavelength"] = df.loc[peak_idx, "wavelength"]
        stats[f"{col_prefix}peak_cross_section"] = df.loc[peak_idx, col]
        stats[f"{col_prefix}mean_cross_section"] = df[col].mean()
    return stats

def calculate_fluorophore_stats(df: pd.DataFrame, fluorophore_name: str) -> Dict[str, float]:
    """Calculate statistics for the fluorophore data."""
    stats = {}

    if fluorophore_name == "IntrinsicFluorophores":
        # Calculate stats for each fluorophore
        intrinsic_columns = ["riboflavin", "folic_acid", "cholecalciferol", "retinol"]
        stats.update(_calculate_column_stats(df, intrinsic_columns))

    elif fluorophore_name == "NADH-ProteinBound":
        # Calculate stats for each form
        nadh_columns = ["gm_mean", "gm_mdh", "gm_ad"]
        stats.update(_calculate_column_stats(df, nadh_columns))
        
        # Add standard deviation if available
        if "sd" in df.columns:
            stats["mean_std_dev"] = df["sd"].mean()

    else:
        # Standard statistics for single-trace fluorophores
        cross_section_col = "cross_section" if "cross_section" in df.columns else df.columns[1]
        peak_idx = df[cross_section_col].idxmax()
        stats["peak_wavelength"] = df.loc[peak_idx, "wavelength"]
        stats["peak_cross_section"] = df.loc[peak_idx, cross_section_col]
        stats["mean_cross_section"] = df[cross_section_col].mean()
        if "std_dev" in df.columns:
            stats["mean_std_dev"] = df["std_dev"].mean()

    return stats

def format_stats(stats: Dict[str, float]) -> str:
    """Format statistics for display."""
    formatted = []
    for key, value in stats.items():
        if "wavelength" in key:
            formatted.append(f"**{key.replace('_', ' ').title()}:** {value:.0f} nm")
        elif "cross_section" in key:
            formatted.append(f"**{key.replace('_', ' ').title()}:** {value:.2e} GM")
        elif "std_dev" in key:
            formatted.append(f"**{key.replace('_', ' ').title()}:** {value:.2e}")
    return "\n\n".join(formatted)

def handle_component_error(operation: str, fluorophore_name: str, error: Exception) -> None:
    """Handle errors in component operations with consistent logging and user feedback."""
    logger.error(f"Error {operation} for {fluorophore_name}: {error}")
    
    # Define error messages for different operations
    error_messages = {
        "plotting data": f"Error plotting data for {fluorophore_name}: {str(error)}",
        "displaying reference image": "Could not display reference image."
    }
    
    # Get the appropriate error message or use a default
    message = error_messages.get(operation, f"Error in {operation}: {str(error)}")
    
    # Display appropriate UI feedback
    if operation == "plotting data":
        st.error(message)
    else:
        st.warning(message)

def render_fluorophore_viewer(cross_sections: Dict[str, pd.DataFrame], key_prefix: str = "") -> None:
    """Render the fluorophore viewer component."""
    if not cross_sections:
        st.warning("No cross-section data available.")
        return

    # Create a dropdown for fluorophore selection
    fluorophore_names = sorted(cross_sections.keys())
    selected_fluorophore = st.selectbox(
        "Select Fluorophore",
        options=fluorophore_names,
        help="Choose a fluorophore to view its two-photon cross section data",
        key=f"{key_prefix}_fluorophore_selector"
    )

    # Create columns for plot and reference/stats
    col1, col2 = st.columns([2, 1])

    with col1:
        st.write("**Cross Section Plot**")
        try:
            fig = plot_cross_section(
                cross_sections=cross_sections,
                selected_fluorophore=selected_fluorophore,
                height=500,
                width=700,
                show_error_bars=True
            )
            st.plotly_chart(fig, use_container_width=True, key=f"{key_prefix}_plot")
        except Exception as e:
            handle_component_error("plotting data", selected_fluorophore, e)

    with col2:
        # Statistics Section
        st.write("**Statistics**")
        df = cross_sections[selected_fluorophore]
        stats = calculate_fluorophore_stats(df, selected_fluorophore)
        st.markdown(format_stats(stats))

        # Reference Image
        st.write("**Reference Plot**")
        try:
            image_url = get_reference_image_url(selected_fluorophore)
            image_content = fetch_image_content(image_url)
            if image_content:
                st.image(
                    image_content,
                    caption=f"Reference plot for {selected_fluorophore}",
                    use_container_width=True
                )
            else:
                st.info(f"Reference image not found or failed to load for {selected_fluorophore}.")
        except Exception as e:
            handle_component_error("displaying reference image", selected_fluorophore, e)

    # Data Table Section
    with st.expander("Raw Data", expanded=False):
        df = cross_sections[selected_fluorophore]
        st.dataframe(
            df,
            use_container_width=True,
            hide_index=True,
            key=f"{key_prefix}_dataframe"
        )

        # Download button for raw data
        csv_data = df.to_csv(index=False)
        st.download_button(
            label="Download Raw Data",
            data=csv_data,
            file_name=f"{selected_fluorophore}_data.csv",
            mime="text/csv",
            key=f"{key_prefix}_download_{selected_fluorophore}",
        )
